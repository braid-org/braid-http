<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th:first-child, td:first-child {
            width: 50%;
        }
        th:not(:first-child), td:not(:first-child) {
            width: 25%;
            overflow: scroll;
            white-space: nowrap;
        }
        th {
            background-color: #f2f2f2;
        }
        .running {
            background-color: #fffde7;
        }
        .passed {
            background-color: #e8f5e9;
        }
        .failed {
            background-color: #ffebee;
        }
        .section-header {
            background-color: #fefefe;
            font-weight: bold;
        }
        #summaryContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 20px;
        }
        .summaryBox {
            width: 25px;
            height: 25px;
            border: 1px solid #ddd;
        }
    </style>
</head>
<script src="/braid-http-client.js"></script>
<div id="summaryContainer"></div>
<table id="testTable">
    <tr>
        <th>Name</th>
        <th>Your Server's Responses</th>
        <th>Known Server Responses</th>
    </tr>
</table>
<script type="module">

var og_fetch = fetch
fetch = braid_fetch
let test_update = {
    version: ['test'],
    parents: ['oldie'],
    body: JSON.stringify({this: 'stuff'}),
    status: "200"
}
let delay = 0

function createTestRow(testName, expected) {
    const row = document.createElement("tr")
    row.innerHTML = `
        <td>${testName}</td>
        <td class="result">Running...</td>
    `
    row.className = "running"
    testTable.appendChild(row)

    const expectedCell = document.createElement("td")
    expectedCell.textContent = expected
    row.appendChild(expectedCell)

    return row
}

function updateTestResult(row, passed, got) {
    row.className = passed ? "passed" : "failed"
    
    const resultCell = row.querySelector(".result")
    resultCell.textContent = got
}

function addSectionHeader(headerText) {
    addSectionHeader.my_func = () => {
        const row = document.createElement("tr")
        for (let i = 0; i < 3; i++) {
            let cell = document.createElement("td")
            cell.textContent = i == 0 ? headerText : ''
            cell.className = "section-header"
            row.appendChild(cell)
        }
        testTable.appendChild(row)
    }
}

let summaryContainer = document.getElementById('summaryContainer');

function createSummaryBox() {
    const box = document.createElement('div');
    box.className = 'summaryBox running';
    summaryContainer.appendChild(box);
    return box;
}

function updateSummaryBox(box, passed) {
    box.className = `summaryBox ${passed ? 'passed' : 'failed'}`;
}

var wait_for_me = Promise.resolve()
var wait_list = []

function waitForTests(cb) {
    wait_for_me = Promise.all(wait_list).then(() => cb())
    wait_list = []    
}

function runTest(testName, testFunction, expectedResult) {
    wait_list.push((async () => {
        let func = addSectionHeader.my_func
        addSectionHeader.my_func = null

        await wait_for_me

        delay += 70

        await new Promise(done => setTimeout(done, delay))
        func?.()
        const row = createTestRow(testName, expectedResult)
        const summaryBox = createSummaryBox()

        try {
            let got = await testFunction()
            if (got == expectedResult) {
                updateTestResult(row, true, got)
                updateSummaryBox(summaryBox, true)
            } else {
                updateTestResult(row, false, got)
                updateSummaryBox(summaryBox, false)
            }
        } catch (error) {
            updateTestResult(row, false, error.message || error)
            updateSummaryBox(summaryBox, false)
        }
    })())
}

addSectionHeader("Multiplexing Tests")

var multiplex_version = '1.0'
braid_fetch.enable_multiplex = {}

runTest(
    "Basic MULTIPLEX method test.",
    async () => {
        var m = Math.random().toString(36).slice(2)
        var r = await og_fetch(`/${m}`, {method: 'MULTIPLEX', headers: {'Multiplex-Version': multiplex_version}})
        var {done, value} = await r.body.getReader().read()
        return !!(r.ok && value)
    },
    true
)

runTest(
    "Test retrying MULTIPLEX if duplicate id (with new id).",
    async () => {
        var a = new AbortController()
        var m = Math.random().toString(36).slice(2)
        var s = Math.random().toString(36).slice(2)
        var r = await fetch('/json', {
            signal: a.signal,
            subscribe: true,
            headers: { 'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}` },
            retry: true
        })
        delete multiplex_fetch.multiplexers[m]
        s = Math.random().toString(36).slice(2)
        var r = await fetch('/json', {
            signal: a.signal,
            subscribe: true,
            retry: true,
            onFetch: (url, params) => {
                if (m) params.headers.set('Multiplex-Through', `/.well-known/multiplexer/${m}/${s}`)
                else params.headers.delete('Multiplex-Through')
                m = null
            }
        })
        return '' + !!r.is_multiplexed
    },
    'true'
)

runTest(
    `Test for "Incremental: ?1" header in multiplexer response.`,
    async () => {
        var m = Math.random().toString(36).slice(2)
        var r = await og_fetch(`/${m}`, {method: 'MULTIPLEX', headers: {'Multiplex-Version': multiplex_version}})
        return r.headers.get('Incremental')
    },
    '?1'
)

runTest(
    "Test handling duplicate request id",
    async () => {
        var a = new AbortController()
        var m = Math.random().toString(36).slice(2)
        var s = Math.random().toString(36).slice(2)
        var r = await fetch('/json', {
            signal: a.signal,
            subscribe: true,
            headers: { 'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}` },
            retry: true
        })

        var a = new AbortController()
        var count = 0
        await fetch('/json', {
            signal: a.signal,
            subscribe: true,
            retry: true,
            onFetch: (url, params) => {
                count++
                params.headers.set('Multiplex-Through', `/.well-known/multiplexer/${m}/${s}`)
                s = Math.random().toString(36).slice(2)
            }
        })
        await og_fetch('/kill_mux', {headers: {mux: m}})
        return 'count: ' + count
    },
    'count: 2'
)

runTest(
    "Test falling back to MULTIPLEX well-known url, if method doesn't work.",
    async () => {
        var a = new AbortController()
        var m = 'bad_mux_method'
        var s = Math.random().toString(36).slice(2)
        var r = await fetch('/json', {
            signal: a.signal,
            subscribe: true,
            headers: { 'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}` },
            retry: true
        })
        await og_fetch('/kill_mux', {headers: {mux: m}})
        return '' + !!r.is_multiplexed
    },
    'true'
)

runTest(
    "Test option to use MULTIPLEX well-known url regardless.",
    async () => {
        var a = new AbortController()
        var m = 'bad_mux_well_known_url'
        var s = Math.random().toString(36).slice(2)
        try {
            var r = await fetch('/json', {
                signal: a.signal,
                subscribe: true,
                multiplex: {via: 'POST'},
                headers: { 'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}` },
                retry: true
            })
        } catch (e) {
            return e.message.slice(0, 'Could not establish multiplexed request'.length)
        }
        return 'hm..'
    },
    'Could not establish multiplexed request'
)

runTest(
    "Test that when multiplexer doesn't exist, it returns the proper header.",
    async () => {
        var a = new AbortController()
        var m = Math.random().toString(36).slice(2)
        var s = Math.random().toString(36).slice(2)
        var r = await og_fetch('/json', {headers: {'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}`, 'Multiplex-Version': multiplex_version}})
        return r.headers.get('bad-multiplexer') === m
    },
    true
)

runTest(
    "Test that multiplexer code handles a full url (rather than relative one).",
    async () => {
        var a1 = new AbortController()
        var r1 = await fetch('https://localhost:9000/json', {
            signal: a1.signal,
            subscribe: true,
        })

        var a2 = new AbortController()
        var r2 = await fetch('https://localhost:9000/json', {
            signal: a2.signal,
            subscribe: true,
        })

        if (!r2.is_multiplexed) throw new Error('not multiplexed')

        let ret = await new Promise(done => r2.subscribe(u => {
            u.body = u.body_text
            done(JSON.stringify(u))
        }))

        a1.abort()
        a2.abort()

        return ret
    },
    JSON.stringify(test_update)
)

runTest(
    "Test that multiplexer code handles a full url (rather than relative one) on server.",
    async () => {
        var r = await fetch('/eval', {
            method: 'POST',
            body: `
            void (async () => {
                braid_fetch.enable_multiplex = true

                var a = new AbortController()
                var r = await braid_fetch('https://localhost:' + port + '/json', {
                    signal: a.signal,
                    subscribe: true,
                    retry: true
                })

                if (!r.is_multiplexed) return res.end('not multiplexer!?')

                r.subscribe(u => {
                    u.body = u.body_text
                    if (!res.writableEnded) {
                        res.end(JSON.stringify(u))
                        a.abort()
                        braid_fetch.enable_multiplex = false
                    }
                })
            })()
            `
        })
        return await r.text()
    },
    JSON.stringify(test_update)
)

runTest(
    "Test closing unrecognized requests in the multiplexer.",
    async () => {
        var a = new AbortController()
        var m = Math.random().toString(36).slice(2)
        var s = Math.random().toString(36).slice(2)
        var r = await fetch('/json', {signal: a.signal, headers: {'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}`, 'Multiplex-Version': multiplex_version}})

        var s2 = Math.random().toString(36).slice(2)
        var r2 = await fetch('/eval', {
            method: 'POST',
            body: `
            void (async () => {
                braidify.multiplexers.get(${JSON.stringify(m)}).res.write('start response ${s2}\\r\\n'.repeat(3))

                setTimeout(() => {
                    braidify.multiplexers.get(${JSON.stringify(m)}).res.write('start response ${s2}\\r\\n'.repeat(3))
                }, 300)

                setTimeout(() => {
                    res.end(JSON.stringify(deleted_request_count[${JSON.stringify(s2)}]))
                }, 600)
            })()
            `
        })
        return await r2.text()
    },
    '2'
)

runTest(
    "Test receiving multiplexed message.",
    async () => {
        var a = new AbortController()
        var m = Math.random().toString(36).slice(2)
        var s = Math.random().toString(36).slice(2)
        var r = await fetch('/json', {
            signal: a.signal,
            subscribe: true,
            headers: {
                'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}`
            }
        })
        if (!r.is_multiplexed) throw new Error('not multiplexed')
        var x = await new Promise(async done => {
            r.subscribe(u => {
                u.body = u.body_text
                done(JSON.stringify(u))
            })
        })
        a.abort()
        return x
    },
    JSON.stringify(test_update)
)

runTest(
    "Test receiving multiplexed messages with whitespace between them.",
    async () => {
        var a = new AbortController()
        var m = Math.random().toString(36).slice(2)
        var s = Math.random().toString(36).slice(2)
        var r = await fetch('/json', {
            signal: a.signal,
            subscribe: true,
            headers: { 'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}` }
        })
        if (!r.is_multiplexed) throw new Error('not multiplexed')
        var x = await new Promise(async done => {
            r.subscribe(u => {

                console.log('u = ', u)

                u.body = u.body_text
                if (u.version[0] === 'test1') done(u.version[0])
            })
        })
        await og_fetch('/kill_mux', {headers: {mux: m}})
        a.abort()
        return x
    },
    'test1'
)

runTest(
    "Test receiving multiplexed message using subscription",
    async () => {
        var a1 = new AbortController()
        var r1 = await fetch('/json', {
            signal: a1.signal,
            subscribe: true,
        })

        var a2 = new AbortController()
        var r2 = await fetch('/json', {
            signal: a2.signal,
            subscribe: true,
            multiplex: true,
        })

        if (!r2.is_multiplexed) throw new Error('not multiplexed')

        var x = await new Promise(done => {
            r2.subscribe(u => {
                u.body = u.body_text
                done(JSON.stringify(u))
            })
        })

        a1.abort()
        a2.abort()

        return x
    },
    JSON.stringify(test_update)
)

runTest(
    "Test closing multiplexer",
    async () => {
        var a = new AbortController()
        var m = Math.random().toString(36).slice(2)
        var s = Math.random().toString(36).slice(2)
        var r = await fetch('/json', {
            signal: a.signal,
            subscribe: true,
            headers: {
                'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}`
            }
        })
        if (!r.is_multiplexed) throw new Error('not multiplexed')
        var x = await new Promise(async done => {
            r.subscribe(u => {
            }, e => done('multiplexer ended'))
            await og_fetch('/kill_mux', {headers: {mux: m}})
        })
        a.abort()
        return x
    },
    'multiplexer ended'
)

runTest(
    "Test closing multiplexer before headers received",
    async () => {
        var a = new AbortController()
        var m = Math.random().toString(36).slice(2)
        var s = Math.random().toString(36).slice(2)
        setTimeout(() => {
            og_fetch('/kill_mux', {headers: {mux: m}})
        }, 500)
        try {
            var r = await fetch('/eval', {
                method: 'POST',
                signal: a.signal,
                headers: { 'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}` },
                body: `
                    setTimeout(() => {
                        res.setHeader('test', '42')
                        res.end('hi')
                    }, 1000)
                `});
        } catch (e) { return '' + e }
        return 'hm..'
    },
    'Error: multiplex stream ended unexpectedly'
)

runTest(
    "Test closing multiplexer with retry",
    async () => {
        return await new Promise(async done => {
            var count = 0
            var a = new AbortController()
            var m = Math.random().toString(36).slice(2)
            var s = Math.random().toString(36).slice(2)
            var r = await fetch('/json', {
                signal: a.signal,
                subscribe: true,
                headers: { 'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}` },
                retry: { onRes: () => count++ }
            })
            if (!r.is_multiplexed) throw new Error('not multiplexed')
            r.subscribe(u => {
                if (count === 2) {
                    u.body = u.body_text
                    done(JSON.stringify(u))
                    a.abort()
                }
            }, e => {})
            await og_fetch('/kill_mux', {headers: {mux: m}})
        })
    },
    JSON.stringify(test_update)
)

runTest(
    "Test aborting multiplexed subscription.",
    async () => {
        await fetch('/json', {subscribe: true})
        let good = false
        let a = new AbortController()
        try {
            let res = await fetch("/json", {
                signal: a.signal,
                retry: true,
                subscribe: true,
            })
            await new Promise((done, fail) => {
                setTimeout(() => a.abort(), 30)
                setTimeout(() => fail(new Error("abort failed 1")), 60)
                res.subscribe((update) => {
                    if (update.body != null) update.body = update.body_text
                    if (JSON.stringify(update) === JSON.stringify(test_update)) good = true
                }, fail)
            })
        } catch (e) {
            return e.name === "AbortError" && good ? "passed" : "failed"
        }
    },
    "passed"
)

runTest(
    "Test ending multiplexed subscription on the server side.",
    async () => {
        var onRes_count = 0
        var update_count = 0
        try {
            await new Promise(async (done, fail) => {
                var a = new AbortController()
                var res = await fetch("/json", {
                    retry: { onRes: () => onRes_count++ },
                    subscribe: true,
                    multiplex: true,
                    signal: a.signal,
                    headers: {
                        giveup: true,
                    }
                })
                res.subscribe(
                    (update) => {
                        if (update.body != null) update.body = update.body_text
                        if (JSON.stringify(update) === JSON.stringify(test_update)) update_count++
                        if (update_count > 1) done()
                    },
                    (e) => fail(new Error("fetch error: " + e))
                )
                setTimeout(() => {
                    a.abort()
                    fail(new Error("timed out: " + JSON.stringify({ onRes_count, update_count })))
                }, 3000)
            })
            return `onRes_count=${onRes_count}, update_count=${update_count}`
        } catch (e) {
            return e.message
        }
    },
    "onRes_count=2, update_count=2"
)

runTest(
    "Test retry when first establishinig multiplexer",
    async () => {
        if ((await (await og_fetch('/eval', {
            method: 'POST',
            body: `
                faulty_mux_i = 0
                res.end('ok!')
            `})).text()) !== 'ok!') throw new Error('fail to reset_faulty_mux')

        var a = new AbortController()
        var m = 'faulty_mux'
        var s = Math.random().toString(36).slice(2)
        var r = await fetch('/json', {
            signal: a.signal,
            subscribe: true,
            headers: { 'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}` },
            retry: true
        })
        if (!r.is_multiplexed) throw new Error('not multiplexed')
        a.abort()
        return 'multiplexed!'
    },
    'multiplexed!'
)

runTest(
    "Test that server multiplexer can detect closure.",
    async () => {
        var a = new AbortController()
        var m = Math.random().toString(36).slice(2)
        var s = Math.random().toString(36).slice(2)
        var r = await fetch('/eval', {
            method: 'POST',
            signal: a.signal,
            headers: { 'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}` },
            body: `
                res.setHeader('test', '42')
                res.startSubscription({
                    onClose: () => {
                        _${m} = 42
                    }
                })
                res.write('\\r\\n')
            `});
        if (r.headers.get('test') !== '42') throw new Error('sad')
        await og_fetch('/kill_mux', {headers: {mux: m}})
        var r2 = await fetch('/eval', {
            method: 'POST',
            signal: a.signal,
            body: `
                res.end('' + _${m})
            `});
        var x = await r2.text()
        a.abort()
        return x
    },
    '42'
);

runTest(
    "Test failing to establish multiplexed connection.",
    async () => {
        var a = new AbortController()
        var m = 'bad_mux'
        var s = Math.random().toString(36).slice(2)
        try {
            var r = await fetch('/json', {
                signal: a.signal,
                subscribe: true,
                headers: { 'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}` }
            })
        } catch (e) { return e.message }
        return 'hm..'
    },
    'multiplexer not yet connected'
);

runTest(
    "Test that creating duplicate multiplexed connections fails correctly.",
    async () => {
        var a = new AbortController()
        var m = Math.random().toString(36).slice(2)
        var s = Math.random().toString(36).slice(2)
        var r = await fetch('/json', {
            signal: a.signal,
            subscribe: true,
            headers: { 'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}` }
        })

        var r2 = await og_fetch(`/${m}`, {method: 'MULTIPLEX', headers: {'Multiplex-Version': multiplex_version}})
        var o = await r2.json()
        return `status: ${r2.status}, json.error: ` + o.error + `, error as expected: ${JSON.stringify(o) === JSON.stringify({
            "error": "Multiplexer already exists",
            "details": `Cannot create duplicate multiplexer with ID '${m}'`
        })}`
    },
    'status: 409, json.error: Multiplexer already exists, error as expected: true'
);

runTest(
    "Test that creating duplicate multiplexed requests fails correctly.",
    async () => {
        var a = new AbortController()
        var m = Math.random().toString(36).slice(2)
        var s = Math.random().toString(36).slice(2)
        var r = await fetch('/json', {
            signal: a.signal,
            subscribe: true,
            headers: { 'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}` }
        })

        var r2 = await og_fetch(`/json`, {signal: a.signal, subscribe: true, headers: {'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}`, 'Multiplex-Version': multiplex_version}})
        var o = await r2.json()
        return `status: ${r2.status}, json.error: ` + o.error + `, error as expected: ${JSON.stringify(o) === JSON.stringify({
            "error": "Request already multiplexed",
            "details": `Cannot multiplex request with duplicate ID '${s}' for multiplexer '${m}'`,
        })}`
    },
    'status: 409, json.error: Request already multiplexed, error as expected: true'
);

runTest(
    "Test failing to establish multiplexed request.",
    async () => {
        var a = new AbortController()
        var m = Math.random().toString(36).slice(2)
        var s = Math.random().toString(36).slice(2)
        try {
            var r = await fetch('/500', {
                signal: a.signal,
                headers: { 'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}` },
            })
        } catch (e) { return ('' + e).slice(0, 'Error: Could not establish multiplexed request'.length) }
        return 'hm..'
    },
    'Error: Could not establish multiplexed request'
);

runTest(
    "Test failing to close multiplexed request.",
    async () => {
        return await new Promise(async done => {
            window.addEventListener('unhandledrejection', function (event) {
                if (event.reason.message === 'Could not cancel multiplexed request: Error: giving up because of http status: 404') done('saw the error we wanted')
            })

            var m = Math.random().toString(36).slice(2)
            var s = 'bad_request'
            fetch('/500', { headers: { 'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}` } })
        })
    },
    'saw the error we wanted'
);

runTest(
    "Test header syntax error in multiplexed stream.",
    async () => {
        var a = new AbortController()
        var m = Math.random().toString(36).slice(2)
        var s = Math.random().toString(36).slice(2)
        try {
            var r = await fetch('/eval', {
                method: 'POST',
                signal: a.signal,
                headers: { 'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}` },
                body: `
                    var m = braidify.multiplexers?.get(${JSON.stringify(m)})
                    m.res.write('10 bytes for response ${s}\\r\\na b\\r\\na b\\r\\n')
                    setTimeout(() => {
                        m.res.write('2 bytes for response ${s}\\r\\n\\r\\n')
                        res.write('aaaaabbbb')
                    }, 1000)
                `
            })
        } catch (e) { return '' + e }
        return 'hm..: ' + r.status + (await r.body.getReader().read()).value
    },
    'Error: error parsing headers'
);

runTest(
    "Test 2nd GET causing multiplexed connection.",
    async () => {
        var a = new AbortController()
        var r = await fetch('/json', {
            signal: a.signal,
            subscribe: true,

            multiplex: true
        })
        var r2 = await fetch('/json', {
            signal: a.signal,
            subscribe: true,

            multiplex: true
        })
        setTimeout(() => a.abort(), 0)
        return '' + !!r2.is_multiplexed
    },
    'true'
);

runTest(
    "Test stream parsing error.",
    async () => {
        var a = new AbortController()
        var r = await fetch('/eval', {
            signal: a.signal,
            method: 'POST',
            subscribe: true,
            body: `
                res.write('\\r\\n\\r\\n\\r\\nHTP 555\\r\\n\\r\\n\\r\\n')
            `
        })
        setTimeout(() => a.abort(), 2000)
        return await new Promise((done, fail) => {
            r.subscribe(u => {
                done(JSON.stringify(u))

            }, e => {
                done('' + e)

            })

        })
    },
    'Parse error in headers: ""HTP 555\\r\\n\\r\\n""'
);

runTest(
    "Test server getting GET for multiplexer that doesn't exist.",
    async () => {
        var a = new AbortController()
        var m = Math.random().toString(36).slice(2)
        var s = Math.random().toString(36).slice(2)

        var s2 = Math.random().toString(36).slice(2)
        var r2 = await fetch('/json', {
            signal: a.signal,
            subscribe: true,
            headers: { 'Multiplex-Through': `/.well-known/multiplexer/${m}/${s2}` },
        })

        try {
            var r = await fetch('/eval_pre_braidify', {
                method: 'POST',
                signal: a.signal,
                headers: { 'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}` },
                body: `
                    braidify.multiplexers.delete(${JSON.stringify(m)})
                    'keep going'
                `});
        } catch (e) { return ('' + e).slice(0, 'Error: Could not establish multiplexed request'.length) + '..'}
        finally { a.abort() }
        return 'hm..'
    },
    'Error: Could not establish multiplexed request..'
);

runTest(
    "Test multiplexed request aborted before GET, on server",
    async () => {
        var a = new AbortController()
        var m = Math.random().toString(36).slice(2)
        var s = Math.random().toString(36).slice(2)
        var s2 = Math.random().toString(36).slice(2)
        await fetch('/json', {
            subscribe: true,
            headers: { 'Multiplex-Through': `/.well-known/multiplexer/${m}/${s2}` }
        })
        var r = await og_fetch(`/${m}/${s}`, {method: 'MULTIPLEX', headers: {'Multiplex-Version': multiplex_version}})
        return r.status
    },
    '404'
)

waitForTests(() => {})

runTest(
    "Test client asking for multiplexing, but server doesn't realize it.",
    async () => {
        await fetch('/eval', {
            method: 'POST',
            body: `
                braidify.enable_multiplex = false
                res.end('ok')
            `
        })

        var a = new AbortController()
        var m = Math.random().toString(36).slice(2)
        var s = Math.random().toString(36).slice(2)
        var r = await fetch('/json', {
            signal: a.signal,
            subscribe: true,
            headers: { 'Multiplex-Through': `/.well-known/multiplexer/${m}/${s}` }
        })
        return await new Promise(done => {
            r.subscribe(u => {
                u.body = u.body_text
                done(JSON.stringify(u))
                a.abort()
            })
        })
    },
    JSON.stringify(test_update)
)

waitForTests(() => braid_fetch.enable_multiplex = false)

addSectionHeader("Server sending binary data with sendUpdate")

runTest(
    "Server can send binary body when not subscribing",
    async () => {
        let a = new AbortController()
        let x = await new Promise((resolve, reject) => {
            fetch('/json', {headers: {skip_first: true, send_binary_body: true, giveup: true}}).then(x => x.arrayBuffer()).then(resolve)
        })
        return '' + new Uint8Array(x)
    },
    '0,1,2,3'
)

runTest(
    "Server can send binary body as ArrayBuffer",
    async () => {
        let a = new AbortController()
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, multiplex: false, signal: a.signal, headers: {skip_first: true, send_binary_body_arraybuffer: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(update.body)
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
    },
    '0,1,2,3'
)

runTest(
    "Server can send binary body as Uint8Array",
    async () => {
        let a = new AbortController()
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, multiplex: false, signal: a.signal, headers: {skip_first: true, send_binary_body: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(update.body)
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
    },
    '0,1,2,3'
)

runTest(
    "Server can send binary body as Blob",
    async () => {
        let a = new AbortController()
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, multiplex: false, signal: a.signal, headers: {skip_first: true, send_binary_body_blob: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(update.body)
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
    },
    '0,1,2,3'
)

runTest(
    "Server can send binary body as Buffer",
    async () => {
        let a = new AbortController()
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, multiplex: false, signal: a.signal, headers: {skip_first: true, send_binary_body_buffer: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(update.body)
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
    },
    '0,1,2,3'
)

runTest(
    "Server can send binary patch as ArrayBuffer",
    async () => {
        let a = new AbortController()
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, multiplex: false, signal: a.signal, headers: {skip_first: true, send_binary_patch_arraybuffer: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(update.patches[0].content)
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
    },
    '0,1,2,3'
)

runTest(
    "Server can send binary patch as Uint8Array",
    async () => {
        let a = new AbortController()
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, multiplex: false, signal: a.signal, headers: {skip_first: true, send_binary_patch: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(update.patches[0].content)
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
    },
    '0,1,2,3'
)

runTest(
    "Server can send binary patch as Blob",
    async () => {
        let a = new AbortController()
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, multiplex: false, signal: a.signal, headers: {skip_first: true, send_binary_patch_blob: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(update.patches[0].content)
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
    },
    '0,1,2,3'
)

runTest(
    "Server can send binary patch as Buffer",
    async () => {
        let a = new AbortController()
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, multiplex: false, signal: a.signal, headers: {skip_first: true, send_binary_patch_buffer: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(update.patches[0].content)
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
    },
    '0,1,2,3'
)

runTest(
    "Server can send multiple binary patches as ArrayBuffers",
    async () => {
        let a = new AbortController()
        let x = await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, multiplex: false, signal: a.signal, headers: {skip_first: true, send_binary_patches_arraybuffer: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(new Blob([update.patches[0].content, update.patches[1].content]))
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
        x = await x.arrayBuffer()
        return '' + new Uint8Array(x)
    },
    '0,1,2,3,10,11,12,13'
)

runTest(
    "Server can send multiple binary patches as Uint8Arrays",
    async () => {
        let a = new AbortController()
        let x = await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, multiplex: false, signal: a.signal, headers: {skip_first: true, send_binary_patches: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(new Blob([update.patches[0].content, update.patches[1].content]))
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
        x = await x.arrayBuffer()
        return '' + new Uint8Array(x)
    },
    '0,1,2,3,10,11,12,13'
)

runTest(
    "Server can send multiple binary patches as Blobs",
    async () => {
        let a = new AbortController()
        let x = await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, multiplex: false, signal: a.signal, headers: {skip_first: true, send_binary_patches_blob: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(new Blob([update.patches[0].content, update.patches[1].content]))
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
        x = await x.arrayBuffer()
        return '' + new Uint8Array(x)
    },
    '0,1,2,3,10,11,12,13'
)

runTest(
    "Server can send multiple binary patches as Buffers",
    async () => {
        let a = new AbortController()
        let x = await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, multiplex: false, signal: a.signal, headers: {skip_first: true, send_binary_patches_buffer: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(new Blob([update.patches[0].content, update.patches[1].content]))
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
        x = await x.arrayBuffer()
        return '' + new Uint8Array(x)
    },
    '0,1,2,3,10,11,12,13'
)

addSectionHeader("Client sending binary data")

runTest(
    "Client can PUT single binary patch as ArrayBuffer",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_patch_binary: true}, patches: {unit: 'text', range: '[0:0]', content: new Uint8Array([0, 1, 2, 3]).buffer}}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '0,1,2,3\n'
)

runTest(
    "Client can PUT single binary patch as Uint8Array",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_patch_binary: true}, patches: {unit: 'text', range: '[0:0]', content: new Uint8Array([0, 1, 2, 3])}}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '0,1,2,3\n'
)

runTest(
    "Client can PUT multiple binary patches as ArrayBuffers",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_patch_binary: true}, patches: [{unit: 'text', range: '[0:0]', content: new Uint8Array([0, 1, 2, 3]).buffer}, {unit: 'text', range: '[0:0]', content: new Uint8Array([10, 11, 12, 13]).buffer}]}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '0,1,2,3\n10,11,12,13\n'
)

runTest(
    "Client can PUT multiple binary patches as Uint8Arrays",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_patch_binary: true}, patches: [{unit: 'text', range: '[0:0]', content: new Uint8Array([0, 1, 2, 3])}, {unit: 'text', range: '[0:0]', content: new Uint8Array([10, 11, 12, 13])}]}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '0,1,2,3\n10,11,12,13\n'
)

runTest(
    "Client can PUT multiple binary patches as Blobs",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_patch_binary: true}, patches: [{unit: 'text', range: '[0:0]', content: new Blob([new Uint8Array([0, 1, 2, 3])])}, {unit: 'text', range: '[0:0]', content: new Blob([new Uint8Array([10, 11, 12, 13])])}]}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '0,1,2,3\n10,11,12,13\n'
)

runTest(
    "Client can PUT single patch with unicode text",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_patch_content_text: true}, patches: [{unit: 'text', range: '[0:0]', content: '🌈👽🎵'}]}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '🌈👽🎵\n'
)

runTest(
    "Client can PUT multiple patches with unicode texts",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_patch_content_text: true}, patches: [{unit: 'text', range: '[0:0]', content: '🌈👽🎵'}, {unit: 'text', range: '[0:0]', content: 'Hello 🌍!'}]}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '🌈👽🎵\nHello 🌍!\n'
)

addSectionHeader("Make sure contents are binary, with property to access as text")

runTest(
    "Verify client-side patches are binary",
    async () => {
        let a = new AbortController()
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, multiplex: false, signal: a.signal, headers: {skip_first: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(update.patches[0].content instanceof Uint8Array)
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
    },
    'true'
)

runTest(
    "Verify client-side patches have content_text",
    async () => {
        let a = new AbortController()
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, multiplex: false, signal: a.signal, headers: {skip_first: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(update.patches[0].content_text)
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
    },
    '1'
)

runTest(
    "Verify server-side bodies are binary",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_body_binary: true}, body: '{"a":5}'}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '123,34,97,34,58,53,125'
)

runTest(
    "Verify server-side bodies have body_text",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_body_text: true}, body: '{"a":5}'}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '{"a":5}'
)

runTest(
    "Verify server-side patches are binary",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_patch_binary: true, 'content-range': 'text [0:0]'}, body: '{"a":5}'}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '123,34,97,34,58,53,125\n'
)

runTest(
    "Verify server-side patches have content_text",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_patch_content_text: true, 'content-range': 'text [0:0]'}, body: '{"a":5}'}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '{"a":5}\n'
)

runTest(
    "Verify server-side 'everything' patches are binary",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_everything_patch_binary: true}, body: '{"a":5}'}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '123,34,97,34,58,53,125'
)

runTest(
    "Verify server-side 'everything' patches have content_text",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_everything_patch_content_text: true}, body: '{"a":5}'}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '{"a":5}'
)

runTest(
    "Handle client-side undefined body_text without exceptions",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, multiplex: false, headers: {skip_first: true}}).then(
                res => res.subscribe(
                    (update) => {
                        try {
                            resolve(update.body_text)
                        } catch (e) {
                            reject(e)
                        }
                    },
                    reject
                )).catch(reject)
        })
    },
    'undefined'
)

addSectionHeader("Misc")

runTest(
    "Verify error in cb stops retry",
    async () => {
        return await new Promise((resolve, reject) => {
            let a = new AbortController()
            fetch('/json', {subscribe: true, multiplex: false, retry: true, signal: a.signal}).then(
                res => res.subscribe(
                    update => { throw Error('My Error') },
                    e => resolve(e.message)
                )).catch(reject)
            setTimeout(() => {
                reject('timed out')
                a.abort()
            }, 1000)
        })
    },
    'My Error'
)

runTest(
    "Verify error in async cb stops retry",
    async () => {
        return await new Promise((resolve, reject) => {
            let a = new AbortController()
            fetch('/json', {subscribe: true, multiplex: false, retry: true, signal: a.signal}).then(
                res => res.subscribe(
                    async update => { throw Error('My Error') },
                    e => resolve(e.message)
                )).catch(reject)
            setTimeout(() => {
                reject('timed out')
                a.abort()
            }, 1000)
        })
    },
    'My Error'
)

runTest(
    "Verify that client writes ASCII versions",
    async () => {
        return await (await fetch("/eval", {
            method: 'POST',
            version: ['hello🌍-0'],
            body: `res.end(req.headers['version'])`
        })).text()
    },
    '"hello\\ud83c\\udf0d-0"'
)

runTest(
    "Verify that server writes ASCII versions",
    async () => {
        let x = await fetch('/json', {headers: {skip_first: true, send_unicode_version: true, giveup: true}})
        return x.headers.get('version')
    },
    '"hello\\ud83c\\udf0d-0"'
)

runTest(
    "Verify that client writes ASCII parents",
    async () => {
        return await (await fetch("/eval", {
            method: 'POST',
            parents: ['hello🌍-0', '🌈-5'],
            body: `res.end(req.headers['parents'])`
        })).text()
    },
    '"hello\\ud83c\\udf0d-0", "\\ud83c\\udf08-5"'
)

runTest(
    "Verify that server writes ASCII parents",
    async () => {
        let x = await fetch('/json', {headers: {skip_first: true, send_unicode_parents: true, giveup: true}})
        return x.headers.get('parents')
    },
    '"hello\\ud83c\\udf0d-0", "\\ud83c\\udf08-5"'
)

runTest(
    "Verify that fetch params are not mutated",
    async () => {
        let x = {
            method: 'PUT',
            patches: [{
                unit: 'text', range: '[0:0]', content: 'hello'
            }]
        }
        let y = await (await fetch("/check_parents", x)).json()
        return x.patches[0].content
    },
    'hello'
)

runTest(
    "Verify content-type with charset=utf-8 is handled correctly",
    async () => {
        let updates = []
        await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, multiplex: false, headers: {charset: true}}).then(
                res => res.subscribe(
                    (update) => {
                        if (update.body != null) update.body = update.body_text
                        if (update.patches) for (let p of update.patches) p.content = p.content_text
                        updates.push(JSON.stringify(update))
                        if (updates.length === 5) resolve()
                    },
                    reject
                )).catch(reject)
        })
        return updates.join('\n')
    },
    '{"version":["test"],"parents":["oldie"],"body":"{\\\"this\\\":\\\"stuff\\\"}","status":"200"}\n' +
    '{"version":["test1"],"parents":["oldie","goodie"],"patches":[{"unit":"json","range":"[1]","content":"1"}],"status":"115","extra_headers":{"hash":"42"}}\n' +
    '{"version":["test2"],"patches":[{"unit":"json","range":"[2]","content":"2"}],"status":"200"}\n' +
    '{"version":["test3"],"patches":[{"unit":"json","range":"[3]","content":"3","extra_headers":{"hash":"43"}},{"unit":"json","range":"[4]","content":"4"}],"status":"200"}\n' +
    '{"version":["another!"],"body":"\\\"!\\\"","status":"200"}'
)

runTest(
    "Verify that parents option results in parents header",
    async () => {
        let x = { parents: ["test-0", "test-1"] }
        let y = await (await fetch("/check_parents", x)).json()
        return y.parents
    },
    '"test-0", "test-1"'
)

runTest(
    "Verify that parents option can be a function",
    async () => {
        let x = { parents: ["test-0", "test-1"] }
        let y = await (await fetch("/check_parents", { parents: () => x.parents })).json()
        return y.parents
    },
    '"test-0", "test-1"'
)

runTest(
    "Verify that parents option can be an async function",
    async () => {
        let x = { parents: ["test-0", "test-1"] }
        let y = await (await fetch("/check_parents", { parents: async () => x.parents })).json()
        return y.parents
    },
    '"test-0", "test-1"'
)


runTest(
    "onFetch test 1",
    async () => {
        let x = await new Promise(async (done, fail) => {
            await fetch('/json', {
                parents: () => ['test'],
                onFetch: (...args) => done(args)
            })
        })
        x[1].headers = Object.fromEntries([...x[1].headers])
        return JSON.stringify(x)
    },
    '["/json",{"headers":{"parents":"\\"test\\""},"cache":"no-cache","signal":{}}]'
)

runTest(
    "onBytes test 1",
    async () => {
        return await new Promise(async (done, fail) => {
            let s = ''
            let x = await fetch('/json', {
                subscribe: true,
                multiplex: false, 
                headers: {giveup: true},
                onBytes: (x) => {
                    s += new TextDecoder('utf-8').decode(x)
                }
            })
            x.subscribe(_ => done(s))
        })
    },
    "HTTP 200 OK\r\nVersion: \"test\"\r\nParents: \"oldie\"\r\nContent-Length: 16\r\n\r\n{\"this\":\"stuff\"}\r\n\r\n"
)

runTest(
    "parents-function test 1",
    async () => {
        let has_parents = null
        let x = { parents: null }
        let res = await (await fetch("/check_parents", { parents: () => x.parents, onFetch: (url, params) => {
            has_parents = JSON.stringify(params.headers.has('parents'))
        } })).json()
        return JSON.stringify({has_parents, res})
    },
    '{"has_parents":"false","res":{}}'
)

addSectionHeader("Heartbeat Tests")

runTest(
    "Verify heartbeat reception",
    async () => {
        let a = new AbortController()
        let x = await new Promise((resolve, reject) => {
            let st = Date.now()
            fetch('/json', {subscribe: true, multiplex: false, heartbeats: 0.5, signal: a.signal, onBytes: () => {
                if (Date.now() - st > 500) resolve('got beat!')
            }}).then(res => res.subscribe(() => {}, reject)).catch(reject)
        })
        a.abort()
        return x
    },
    'got beat!'
)

runTest(
    "Verify absence of unwanted heartbeats",
    async () => {
        let a = new AbortController()
        let x = await new Promise((resolve, reject) => {
            let st = Date.now()
            setTimeout(() => resolve('did not get!'), 1000)
            fetch('/json', {subscribe: true, multiplex: false, signal: a.signal, onBytes: () => {
                if (Date.now() - st > 500) resolve('got beat!')
            }}).then(res => res.subscribe(() => {}, reject)).catch(reject)
        })
        a.abort()
        return x
    },
    'did not get!'
)

runTest(
    "Restart connection on missed heartbeats",
    async () => {
        let res_count = 0
        let a = new AbortController()
        let x = await new Promise((resolve, reject) => {
            fetch('/noheartbeat', {heartbeats: 0.5, signal: a.signal, retry: {
                onRes: () => {
                    res_count++
                    if (res_count > 1) {
                        resolve('detected no heartbeat')
                    }
                }
            }}).then(res => res.subscribe(() => {}, reject)).catch(reject)
        })
        a.abort()
        return x
    },
    'detected no heartbeat'
)

runTest(
    "Maintain connection with regular heartbeats",
    async () => {
        let res_count = 0
        let a = new AbortController()
        let x = await new Promise((resolve, reject) => {
            setTimeout(() => resolve("didn't restart"), 1000);
            fetch('/json', {heartbeats: 0.5, subscribe: true, multiplex: false, signal: a.signal, retry: {
                onRes: () => {
                    res_count++
                    if (res_count > 1) {
                        resolve('did restart')
                    }
                }
            }}).then(res => res.subscribe(() => {}, reject)).catch(reject)
        })
        a.abort()
        return x
    },
    "didn't restart"
)

addSectionHeader("Read Tests")

runTest(
    "Subscribe and receive multiple updates, using promise chaining",
    async () => {
        let updates = []
        await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, multiplex: false}).then(
                res => res.subscribe(
                    update => {
                        if (update.body != null) update.body = update.body_text
                        if (update.patches) for (let p of update.patches) p.content = p.content_text
                        updates.push(JSON.stringify(update))
                        if (updates.length === 5) resolve()
                    },
                    reject
                )).catch(reject)
        })
        return updates.join('\n')
    },
    '{"version":["test"],"parents":["oldie"],"body":"{\\\"this\\\":\\\"stuff\\\"}","status":"200"}\n' +
    '{"version":["test1"],"parents":["oldie","goodie"],"patches":[{"unit":"json","range":"[1]","content":"1"}],"status":"115","extra_headers":{"hash":"42"}}\n' +
    '{"version":["test2"],"patches":[{"unit":"json","range":"[2]","content":"2"}],"status":"200"}\n' +
    '{"version":["test3"],"patches":[{"unit":"json","range":"[3]","content":"3","extra_headers":{"hash":"43"}},{"unit":"json","range":"[4]","content":"4"}],"status":"200"}\n' +
    '{"version":["another!"],"body":"\\\"!\\\"","status":"200"}'
)

runTest(
    "Subscribe and receive multiple updates, using async/await",
    async () => {
        let updates = []
        await new Promise(async (resolve, reject) => {
            try {
                (await fetch('/json', {subscribe: true, multiplex: false})).subscribe(
                    update => {
                        if (update.body != null) update.body = update.body_text
                        if (update.patches) for (let p of update.patches) p.content = p.content_text
                        updates.push(JSON.stringify(update))
                        if (updates.length === 5) resolve()
                    },
                    reject
                )
            } catch (e) {
                reject(e)
            }
        })
        return updates.join('\n')
    },
    '{"version":["test"],"parents":["oldie"],"body":"{\\\"this\\\":\\\"stuff\\\"}","status":"200"}\n' +
    '{"version":["test1"],"parents":["oldie","goodie"],"patches":[{"unit":"json","range":"[1]","content":"1"}],"status":"115","extra_headers":{"hash":"42"}}\n' +
    '{"version":["test2"],"patches":[{"unit":"json","range":"[2]","content":"2"}],"status":"200"}\n' +
    '{"version":["test3"],"patches":[{"unit":"json","range":"[3]","content":"3","extra_headers":{"hash":"43"}},{"unit":"json","range":"[4]","content":"4"}],"status":"200"}\n' +
    '{"version":["another!"],"body":"\\\"!\\\"","status":"200"}'
)

runTest(
    "Subscribe and receive multiple updates, using 'for await'",
    async () => {
        let updates = []
        for await (var update of (await fetch('/json', {subscribe: true, multiplex: false})).subscription) {
            if (update.body != null) update.body = update.body_text
            if (update.patches) for (let p of update.patches) p.content = p.content_text
            updates.push(JSON.stringify(update))
            if (updates.length === 5) break
        }
        return updates.join('\n')
    },
    '{"version":["test"],"parents":["oldie"],"body":"{\\\"this\\\":\\\"stuff\\\"}","status":"200"}\n' +
    '{"version":["test1"],"parents":["oldie","goodie"],"patches":[{"unit":"json","range":"[1]","content":"1"}],"status":"115","extra_headers":{"hash":"42"}}\n' +
    '{"version":["test2"],"patches":[{"unit":"json","range":"[2]","content":"2"}],"status":"200"}\n' +
    '{"version":["test3"],"patches":[{"unit":"json","range":"[3]","content":"3","extra_headers":{"hash":"43"}},{"unit":"json","range":"[4]","content":"4"}],"status":"200"}\n' +
    '{"version":["another!"],"body":"\\\"!\\\"","status":"200"}'
)

addSectionHeader("Write Tests")

runTest(
    "PUT with single patch, not in array",
    async () => {
        let res = await fetch('/json', {
            version: ['test1'],
            patches: {unit: 'json', range: '[0]', content: '"test1"'},
            method: 'PUT'
        })
        return `returned ${res.status}`
    },
    "returned 200"
)

runTest(
    "PUT with single patch, in array",
    async () => {
        let res = await fetch('/json', {
            version: ['test2'],
            patches: [{unit: 'json', range: '[0]', content: '"test2"'}],
            method: 'PUT'
        })
        return `returned ${res.status}`
    },
    "returned 200"
)

runTest(
    "PUT with multiples patches",
    async () => {
        let res = await fetch('/json', {
            version: ['test3'],
            patches: [
                {unit: 'jsonpath', range: '[0]', content: '"test3"'},
                {unit: 'jsonpath', range: '[1]', content: '"test3"'},
                {unit: 'jsonpath', range: '[2]', content: '"test3"'}
            ],
            method: 'PUT'
        })
        return `returned ${res.status}`
    },
    "returned 200"
)

runTest(
    "PUT with empty patches array",
    async () => {
        let res = await fetch('/json', {
            version: ['test4'],
            patches: [],
            method: 'PUT'
        })
        return `returned ${res.status}`
    },
    "returned 200"
)

addSectionHeader('Testing braid wrapper for node http(s).get')

runTest(
    "Subscribe and receive multiple updates",
    async () => {
        const codeToEval = `
            let updates = []
            ;(new Promise((resolve, reject) => {
                https.get(
                    'https://localhost:' + port + '/json',
                    {subscribe: true, multiplex: false, rejectUnauthorized: false},
                    (res) => {
                        res.on('update', (update) => {
                            if (update.body != null) update.body = update.body_text
                            if (update.patches) for (let p of update.patches) p.content = p.content_text
                            updates.push(update)
                            if (updates.length === 5) resolve()
                        })
                    }
                )
            })).then(() => {
                res.setHeader('Content-Type', 'application/json');
                res.end(JSON.stringify(updates));
            })
        `;

        const response = await fetch('/eval', {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: codeToEval
        });

        if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);

        const result = await response.json();
        
        return result.map(JSON.stringify).join('\n')
    },
    '{"version":["test"],"parents":["oldie"],"body":"{\\\"this\\\":\\\"stuff\\\"}","status":"200"}\n' +
    '{"version":["test1"],"parents":["oldie","goodie"],"patches":[{"unit":"json","range":"[1]","content":"1"}],"status":"115","extra_headers":{"hash":"42"}}\n' +
    '{"version":["test2"],"patches":[{"unit":"json","range":"[2]","content":"2"}],"status":"200"}\n' +
    '{"version":["test3"],"patches":[{"unit":"json","range":"[3]","content":"3","extra_headers":{"hash":"43"}},{"unit":"json","range":"[4]","content":"4"}],"status":"200"}\n' +
    '{"version":["another!"],"body":"\\\"!\\\"","status":"200"}'
);

runTest(
    "PUT with single patch, not in array",
    async () => {
        const codeToEval = `
            let p = new Promise((resolve, reject) => {
                https.get(
                    'https://localhost:' + port + '/json',
                    {
                        version: ['test1'],
                        patches: {unit: 'json', range: '[0]', content: '"test1"'},
                        method: 'PUT',
                        rejectUnauthorized: false
                    },
                    (res) => {
                        resolve('returned ' + res.statusCode)
                    }
                )            
            })
            p.then(x => {
                res.setHeader('Content-Type', 'application/json');
                res.end(JSON.stringify(x));
            })
        `;

        const response = await fetch('/eval', {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: codeToEval
        });

        if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);

        const result = await response.json();
        return result
    },
    'returned 200'
);

runTest(
    "PUT with single patch, in array",
    async () => {
        const codeToEval = `
            let p = new Promise((resolve, reject) => {
                https.get(
                    'https://localhost:' + port + '/json',
                    {
                        version: ['test2'],
                        patches: [{unit: 'json', range: '[0]', content: '"test2"'}],
                        method: 'PUT',
                        rejectUnauthorized: false
                    },
                    (res) => {
                        resolve('returned ' + res.statusCode)
                    }
                )            
            })
            p.then(x => {
                res.setHeader('Content-Type', 'application/json');
                res.end(JSON.stringify(x));
            })
        `;

        const response = await fetch('/eval', {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: codeToEval
        });

        if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);

        const result = await response.json();
        return result
    },
    'returned 200'
);

runTest(
    "PUT with multiples patches",
    async () => {
        const codeToEval = `
            let p = new Promise((resolve, reject) => {
                https.get(
                    'https://localhost:' + port + '/json',
                    {
                        version: ['test3'],
                        patches: [
                            {unit: 'jsonpath', range: '[0]', content: '"test3"'},
                            {unit: 'jsonpath', range: '[1]', content: '"test3"'},
                            {unit: 'jsonpath', range: '[2]', content: '"test3"'}
                        ],
                        method: 'PUT',
                        rejectUnauthorized: false
                    },
                    (res) => {
                        resolve('returned ' + res.statusCode)
                    }
                )            
            })
            p.then(x => {
                res.setHeader('Content-Type', 'application/json');
                res.end(JSON.stringify(x));
            })
        `;

        const response = await fetch('/eval', {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: codeToEval
        });

        if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);

        const result = await response.json();
        return result
    },
    'returned 200'
);

runTest(
    "PUT with empty patches array",
    async () => {
        const codeToEval = `
            let p = new Promise((resolve, reject) => {
                https.get(
                    'https://localhost:' + port + '/json',
                    {
                        version: ['test4'],
                        patches: [],
                        method: 'PUT',
                        rejectUnauthorized: false
                    },
                    (res) => {
                        resolve('returned ' + res.statusCode)
                    }
                )            
            })
            p.then(x => {
                res.setHeader('Content-Type', 'application/json');
                res.end(JSON.stringify(x));
            })
        `;

        const response = await fetch('/eval', {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: codeToEval
        });

        if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);

        const result = await response.json();
        return result
    },
    'returned 200'
);

addSectionHeader('Testing braid wrapper for node fetch')

runTest(
    "Subscribe and receive multiple updates",
    async () => {
        const codeToEval = `
            let updates = []
            ;(new Promise(async (resolve, reject) => {
                try {
                    (await braid_fetch('https://localhost:' + port + '/json',
                        {subscribe: true, multiplex: false})).subscribe(
                        update => {
                            if (update.body != null) update.body = update.body_text
                            if (update.patches) for (let p of update.patches) p.content = p.content_text
                            updates.push(update)
                            if (updates.length === 5) resolve()
                        },
                        reject
                    )
                } catch (e) {
                    reject(e)
                }            
            })).then(() => {
                res.setHeader('Content-Type', 'application/json');
                res.end(JSON.stringify(updates));
            })
        `;

        const response = await fetch('/eval', {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: codeToEval
        });

        if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);

        const result = await response.json();
        
        return result.map(JSON.stringify).join('\n')
    },
    '{"version":["test"],"parents":["oldie"],"body":"{\\\"this\\\":\\\"stuff\\\"}","status":"200"}\n' +
    '{"version":["test1"],"parents":["oldie","goodie"],"patches":[{"unit":"json","range":"[1]","content":"1"}],"status":"115","extra_headers":{"hash":"42"}}\n' +
    '{"version":["test2"],"patches":[{"unit":"json","range":"[2]","content":"2"}],"status":"200"}\n' +
    '{"version":["test3"],"patches":[{"unit":"json","range":"[3]","content":"3","extra_headers":{"hash":"43"}},{"unit":"json","range":"[4]","content":"4"}],"status":"200"}\n' +
    '{"version":["another!"],"body":"\\\"!\\\"","status":"200"}'
);

runTest(
    "PUT with single patch, not in array",
    async () => {
        const codeToEval = `
            let p = new Promise(async (resolve, reject) => {
                let res = await braid_fetch(
                    'https://localhost:' + port + '/json',
                    {
                        version: ['test1'],
                        patches: {unit: 'json', range: '[0]', content: '"test1"'},
                        method: 'PUT'
                    }
                )

                resolve('returned ' + res.status)
            })
            p.then(x => {
                res.setHeader('Content-Type', 'application/json');
                res.end(JSON.stringify(x));
            })
        `;

        const response = await fetch('/eval', {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: codeToEval
        });

        if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);

        const result = await response.json();
        return result
    },
    'returned 200'
);

runTest(
    "PUT with single patch, in array",
    async () => {
        const codeToEval = `
            let p = new Promise(async (resolve, reject) => {
                var res = await braid_fetch(
                    'https://localhost:' + port + '/json',
                    {
                        version: ['test2'],
                        patches: [{unit: 'json', range: '[0]', content: '"test2"'}],
                        method: 'PUT'
                    }
                )
                resolve('returned ' + res.status)
            })
            p.then(x => {
                res.setHeader('Content-Type', 'application/json');
                res.end(JSON.stringify(x));
            })
        `;

        const response = await fetch('/eval', {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: codeToEval
        });

        if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);

        const result = await response.json();
        return result
    },
    'returned 200'
);

runTest(
    "PUT with multiples patches",
    async () => {
        const codeToEval = `
            let p = new Promise(async (resolve, reject) => {
                var res = await braid_fetch(
                    'https://localhost:' + port + '/json',
                    {
                        version: ['test3'],
                        patches: [
                            {unit: 'jsonpath', range: '[0]', content: '"test3"'},
                            {unit: 'jsonpath', range: '[1]', content: '"test3"'},
                            {unit: 'jsonpath', range: '[2]', content: '"test3"'}
                        ],
                        method: 'PUT'
                    }
                )
                resolve('returned ' + res.status)
            })
            p.then(x => {
                res.setHeader('Content-Type', 'application/json');
                res.end(JSON.stringify(x));
            })
        `;

        const response = await fetch('/eval', {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: codeToEval
        });

        if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);

        const result = await response.json();
        return result
    },
    'returned 200'
);

runTest(
    "PUT with empty patches array",
    async () => {
        const codeToEval = `
            let p = new Promise(async (resolve, reject) => {
                var res = await braid_fetch(
                    'https://localhost:' + port + '/json',
                    {
                        version: ['test4'],
                        patches: [],
                        method: 'PUT'
                    }
                )
                resolve('returned ' + res.status)
            })
            p.then(x => {
                res.setHeader('Content-Type', 'application/json');
                res.end(JSON.stringify(x));
            })
        `;

        const response = await fetch('/eval', {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: codeToEval
        });

        if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);

        const result = await response.json();
        return result
    },
    'returned 200'
);

addSectionHeader("Retry Tests")

runTest(
    "Verify that unparsable headers do not result in retrying connection.",
    async () => {
        let a = new AbortController()
        let count = 0
        return await new Promise(async (done, fail) => {
            let res = await fetch("/parse_error", { retry: {
                onRes: () => {
                    count++
                    if (count === 2) fail('retried')
                }
            }, subscribe: true, multiplex: false, signal: a.signal })
            res.subscribe((u) => {}, done)
        })
    },
    'Parse error in headers: ""hello: true\\r\\nhello\\r\\nContent-Length: 2\\r\\n\\r\\n""'
)

runTest(
    "Should not retry on HTTP 400",
    async () => {
        try {
            await fetch("/400", { retry: true })
            throw new Error("Should have thrown an error")
        } catch (e) {
            return e.message
        }
    },
    "giving up because of http status: 400"
)

runTest(
    "Should not retry on HTTP 401 (access denied)",
    async () => {
        try {
            await fetch("/401", { retry: true })
            throw new Error("Should have thrown an error")
        } catch (e) {
            return e.message
        }
    },
    "giving up because of http status: 401 (access denied)"
)

runTest(
    "Should not try at all if abort controller already aborted",
    async () => {
        let a = new AbortController()
        a.abort()
        try {
            await fetch("/keep_open", { retry: true, signal: a.signal })
            throw new Error("Should have been aborted")
        } catch (e) {
            return e.message
        }
    },
    "already aborted"
)

runTest(
    "Should not retry if aborted",
    async () => {
        let a = new AbortController()
        setTimeout(() => a.abort(), 30)
        try {
            await fetch("/keep_open", { retry: true, signal: a.signal })
            throw new Error("Should have been aborted")
        } catch (e) {
            return e.name
        }
    },
    "AbortError"
)

runTest(
    "Should not retry if aborted, when subscribed",
    async () => {
        let good = false
        let a = new AbortController()
        try {
            let res = await fetch("/json", {
                signal: a.signal,
                retry: true,
                subscribe: true,
                multiplex: false,
            })
            await new Promise((done, fail) => {
                setTimeout(() => a.abort(), 30)
                setTimeout(() => fail(new Error("abort failed 1")), 60)
                res.subscribe((update) => {
                    if (update.body != null) update.body = update.body_text
                    if (JSON.stringify(update) === JSON.stringify(test_update)) good = true
                }, fail)
            })
        } catch (e) {
            return e.name === "AbortError" && good ? "passed" : "failed"
        }
    },
    "passed"
)

runTest(
    "Verify that retry option works with subscribe",
    async () => {
        let a = new AbortController()
        let x = await new Promise(async (done, fail) => {
            try {
                var res = await braid_fetch("/json", {
                    retry: true,
                    signal: a.signal,
                    subscribe: true,
                    multiplex: false,
                })
            } catch (e) {
                fail(e)
            }
            res.subscribe(done, fail)
        })
        a.abort()
        if (x.body != null) x.body = x.body_text
        return JSON.stringify(x)
    },
    JSON.stringify(test_update)
)

var {status, ...test_update_without_status} = test_update
runTest(
    "Should retry on HTTP 408",
    async () => {
        let x = await (await fetch("/retry", { retry: true })).json()
        return JSON.stringify(x)
    },
    JSON.stringify(test_update_without_status)
)

runTest(
    "Verify that onRes is called on first connection",
    async () => {
        try {
            await new Promise((done, fail) => {
                fetch("/", { retry: { onRes: done } })
                setTimeout(() => fail(new Error("onRes was NOT called")), 100)
            })
            return "onRes was called"
        } catch (e) {
            return e.message
        }
    },
    "onRes was called"
)

runTest(
    "Verify that onRes is called on reconnections",
    async () => {
        let onRes_count = 0
        let update_count = 0
        try {
            await new Promise(async (done, fail) => {
                let a = new AbortController()
                let res = await fetch("/json", {
                    retry: { onRes: () => onRes_count++ },
                    subscribe: true,
                    multiplex: false,
                    headers: { giveup: true },
                    signal: a.signal,
                })
                res.subscribe(
                    (update) => {
                        if (update.body != null) update.body = update.body_text
                        if (JSON.stringify(update) === JSON.stringify(test_update)) update_count++
                        if (update_count > 1) done()
                    },
                    (e) => fail(new Error("fetch error: " + e))
                )
                setTimeout(() => {
                    a.abort()
                    fail(new Error("timed out: " + JSON.stringify({ onRes_count, update_count })))
                }, 3000)
            })
            return `onRes_count=${onRes_count}, update_count=${update_count}`
        } catch (e) {
            return e.message
        }
    },
    "onRes_count=2, update_count=2"
)

runTest(
    "Verify that retry works with for-await style subscription",
    async () => {
        let updates = []
        let a = new AbortController()
        for await (var update of (await fetch('/json', {retry: true, signal: a.signal, subscribe: true, multiplex: false, headers: {giveup: true}})).subscription) {
            if (update.body != null) update.body = update.body_text
            updates.push(JSON.stringify(update))

            if (updates.length === 3) break
        }
        a.abort()
        return updates.join('\n')
    },
    '{"version":["test"],"parents":["oldie"],"body":"{\\\"this\\\":\\\"stuff\\\"}","status":"200"}\n' +
    '{"version":["test"],"parents":["oldie"],"body":"{\\\"this\\\":\\\"stuff\\\"}","status":"200"}\n' +
    '{"version":["test"],"parents":["oldie"],"body":"{\\\"this\\\":\\\"stuff\\\"}","status":"200"}'
)

runTest(
    "Should stop retrying in a subscription if reconnection attempt returns HTTP 500",
    async () => {
        let giveup_completely = Math.random().toString(36).slice(2)
        let updates = []
        return await new Promise(async (done, fail) => {
            let res = await fetch('/json', {retry: true, subscribe: true, multiplex: false, headers: {giveup_completely}, multiplex: false})
            res.subscribe((update) => {
                if (update.body != null) update.body = update.body_text
                updates.push(JSON.stringify(update))
            }, (e) => {
                done('' + updates + ' -- ' + e)
            })
        })
    },
    '{"version":["test"],"parents":["oldie"],"body":"{\\"this\\":\\"stuff\\"}","status":"200"} -- Error: giving up because of http status: 500'
)

runTest(
    "Should throw an exception in for-await style when subscription encounters HTTP 500",
    async () => {
        let giveup_completely = Math.random().toString(36).slice(2)
        let updates = []
        try {
            for await (var update of (await fetch('/json', {retry: true, subscribe: true, multiplex: false, headers: {giveup_completely}})).subscription) {
                if (update.body != null) update.body = update.body_text
                updates.push(JSON.stringify(update))
            }
        } catch (e) {
            return '' + updates + ' -- ' + e
        }
    },
    '{"version":["test"],"parents":["oldie"],"body":"{\\"this\\":\\"stuff\\"}","status":"200"} -- Error: giving up because of http status: 500'
)

addSectionHeader('Binary Tests')

runTest(
    "Verify basic binary GET",
    async () => {
        let x = await fetch('/binary')
        x = await x.arrayBuffer()
        x = new Uint8Array(x)
        x = [...x]
        return x.join(', ')
    },
    new Array(256).fill(0).map((x, i) => i).join(', ')
)

runTest(
    "Verify binary data in subscription update",
    async () => {
        let a = new AbortController()
        let x = await new Promise(async (done, fail) => {
            let x = await fetch('/binary', {subscribe: true, multiplex: false, signal: a.signal})
            x.subscribe(done, fail)
        })
        a.abort()
        return '' + x.body
    },
    '' + new Array(256).fill(0).map((x, i) => i)
)

</script>
