<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th:first-child, td:first-child {
            width: 50%;
        }
        th:not(:first-child), td:not(:first-child) {
            width: 25%;
            overflow: scroll;
            white-space: nowrap;
        }
        th {
            background-color: #f2f2f2;
        }
        .running {
            background-color: #fffde7;
        }
        .passed {
            background-color: #e8f5e9;
        }
        .failed {
            background-color: #ffebee;
        }
        .section-header {
            background-color: #fefefe;
            font-weight: bold;
        }
    </style>
</head>
<script src="/braid-http-client.js"></script>
<table id="testTable">
    <tr>
        <th>Name</th>
        <th>Your Server's Responses</th>
        <th>Known Server Responses</th>
    </tr>
</table>
<script type="module">

var fetch = braid_fetch
let test_update = {
    version: ['test'],
    parents: ['oldie'],
    body: JSON.stringify({this: 'stuff'}),
    status: "200"
}
let delay = 0

function createTestRow(testName, expected) {
    const row = document.createElement("tr")
    row.innerHTML = `
        <td>${testName}</td>
        <td class="result">Running...</td>
    `
    row.className = "running"
    testTable.appendChild(row)

    const expectedCell = document.createElement("td")
    expectedCell.textContent = expected
    row.appendChild(expectedCell)

    return row
}

function updateTestResult(row, passed, got) {
    row.className = passed ? "passed" : "failed"
    
    const resultCell = row.querySelector(".result")
    resultCell.textContent = got
}

function addSectionHeader(headerText) {
    addSectionHeader.my_func = () => {
        const row = document.createElement("tr")
        for (let i = 0; i < 3; i++) {
            let cell = document.createElement("td")
            cell.textContent = i == 0 ? headerText : ''
            cell.className = "section-header"
            row.appendChild(cell)
        }
        testTable.appendChild(row)
    }
}

async function runTest(testName, testFunction, expectedResult) {
    let func = addSectionHeader.my_func
    addSectionHeader.my_func = null

    delay += 70

    await new Promise(done => setTimeout(done, delay))
    func?.()
    const row = createTestRow(testName, expectedResult)
    try {
        let got = await testFunction()
        if (got == expectedResult) {
            updateTestResult(row, true, got)
        } else {
            updateTestResult(row, false, got)
        }
    } catch (error) {
        updateTestResult(row, false, error.message || error)
    }
}

addSectionHeader("Server sending binary data with sendUpdate")

runTest(
    "Server can send binary body when not subscribing",
    async () => {
        let a = new AbortController()
        let x = await new Promise((resolve, reject) => {
            fetch('/json', {headers: {skip_first: true, send_binary_body: true, giveup: true}}).then(x => x.arrayBuffer()).then(resolve)
        })
        return '' + new Uint8Array(x)
    },
    '0,1,2,3'
)

runTest(
    "Server can send binary body as ArrayBuffer",
    async () => {
        let a = new AbortController()
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, signal: a.signal, headers: {skip_first: true, send_binary_body_arraybuffer: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(update.body)
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
    },
    '0,1,2,3'
)

runTest(
    "Server can send binary body as Uint8Array",
    async () => {
        let a = new AbortController()
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, signal: a.signal, headers: {skip_first: true, send_binary_body: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(update.body)
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
    },
    '0,1,2,3'
)

runTest(
    "Server can send binary body as Blob",
    async () => {
        let a = new AbortController()
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, signal: a.signal, headers: {skip_first: true, send_binary_body_blob: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(update.body)
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
    },
    '0,1,2,3'
)

runTest(
    "Server can send binary body as Buffer",
    async () => {
        let a = new AbortController()
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, signal: a.signal, headers: {skip_first: true, send_binary_body_buffer: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(update.body)
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
    },
    '0,1,2,3'
)

runTest(
    "Server can send binary patch as ArrayBuffer",
    async () => {
        let a = new AbortController()
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, signal: a.signal, headers: {skip_first: true, send_binary_patch_arraybuffer: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(update.patches[0].content)
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
    },
    '0,1,2,3'
)

runTest(
    "Server can send binary patch as Uint8Array",
    async () => {
        let a = new AbortController()
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, signal: a.signal, headers: {skip_first: true, send_binary_patch: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(update.patches[0].content)
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
    },
    '0,1,2,3'
)

runTest(
    "Server can send binary patch as Blob",
    async () => {
        let a = new AbortController()
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, signal: a.signal, headers: {skip_first: true, send_binary_patch_blob: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(update.patches[0].content)
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
    },
    '0,1,2,3'
)

runTest(
    "Server can send binary patch as Buffer",
    async () => {
        let a = new AbortController()
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, signal: a.signal, headers: {skip_first: true, send_binary_patch_buffer: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(update.patches[0].content)
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
    },
    '0,1,2,3'
)

runTest(
    "Server can send multiple binary patches as ArrayBuffers",
    async () => {
        let a = new AbortController()
        let x = await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, signal: a.signal, headers: {skip_first: true, send_binary_patches_arraybuffer: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(new Blob([update.patches[0].content, update.patches[1].content]))
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
        x = await x.arrayBuffer()
        return '' + new Uint8Array(x)
    },
    '0,1,2,3,10,11,12,13'
)

runTest(
    "Server can send multiple binary patches as Uint8Arrays",
    async () => {
        let a = new AbortController()
        let x = await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, signal: a.signal, headers: {skip_first: true, send_binary_patches: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(new Blob([update.patches[0].content, update.patches[1].content]))
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
        x = await x.arrayBuffer()
        return '' + new Uint8Array(x)
    },
    '0,1,2,3,10,11,12,13'
)

runTest(
    "Server can send multiple binary patches as Blobs",
    async () => {
        let a = new AbortController()
        let x = await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, signal: a.signal, headers: {skip_first: true, send_binary_patches_blob: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(new Blob([update.patches[0].content, update.patches[1].content]))
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
        x = await x.arrayBuffer()
        return '' + new Uint8Array(x)
    },
    '0,1,2,3,10,11,12,13'
)

runTest(
    "Server can send multiple binary patches as Buffers",
    async () => {
        let a = new AbortController()
        let x = await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, signal: a.signal, headers: {skip_first: true, send_binary_patches_buffer: true, giveup: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(new Blob([update.patches[0].content, update.patches[1].content]))
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
        x = await x.arrayBuffer()
        return '' + new Uint8Array(x)
    },
    '0,1,2,3,10,11,12,13'
)

addSectionHeader("Client sending binary data")

runTest(
    "Client can PUT single binary patch as ArrayBuffer",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_patch_binary: true}, patches: {unit: 'text', range: '[0:0]', content: new Uint8Array([0, 1, 2, 3]).buffer}}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '0,1,2,3\n'
)

runTest(
    "Client can PUT single binary patch as Uint8Array",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_patch_binary: true}, patches: {unit: 'text', range: '[0:0]', content: new Uint8Array([0, 1, 2, 3])}}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '0,1,2,3\n'
)

runTest(
    "Client can PUT multiple binary patches as ArrayBuffers",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_patch_binary: true}, patches: [{unit: 'text', range: '[0:0]', content: new Uint8Array([0, 1, 2, 3]).buffer}, {unit: 'text', range: '[0:0]', content: new Uint8Array([10, 11, 12, 13]).buffer}]}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '0,1,2,3\n10,11,12,13\n'
)

runTest(
    "Client can PUT multiple binary patches as Uint8Arrays",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_patch_binary: true}, patches: [{unit: 'text', range: '[0:0]', content: new Uint8Array([0, 1, 2, 3])}, {unit: 'text', range: '[0:0]', content: new Uint8Array([10, 11, 12, 13])}]}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '0,1,2,3\n10,11,12,13\n'
)

runTest(
    "Client can PUT multiple binary patches as Blobs",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_patch_binary: true}, patches: [{unit: 'text', range: '[0:0]', content: new Blob([new Uint8Array([0, 1, 2, 3])])}, {unit: 'text', range: '[0:0]', content: new Blob([new Uint8Array([10, 11, 12, 13])])}]}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '0,1,2,3\n10,11,12,13\n'
)

runTest(
    "Client can PUT single patch with unicode text",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_patch_content_text: true}, patches: [{unit: 'text', range: '[0:0]', content: '游깯游놓游꿧'}]}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '游깯游놓游꿧\n'
)

runTest(
    "Client can PUT multiple patches with unicode texts",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_patch_content_text: true}, patches: [{unit: 'text', range: '[0:0]', content: '游깯游놓游꿧'}, {unit: 'text', range: '[0:0]', content: 'Hello 游깴!'}]}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '游깯游놓游꿧\nHello 游깴!\n'
)

addSectionHeader("Make sure contents are binary, with property to access as text")

runTest(
    "Verify client-side patches are binary",
    async () => {
        let a = new AbortController()
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, signal: a.signal, headers: {skip_first: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(update.patches[0].content instanceof Uint8Array)
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
    },
    'true'
)

runTest(
    "Verify client-side patches have content_text",
    async () => {
        let a = new AbortController()
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, signal: a.signal, headers: {skip_first: true}}).then(
                res => res.subscribe(
                    (update) => {
                        resolve(update.patches[0].content_text)
                        a.abort()
                    },
                    reject
                )).catch(reject)
        })
    },
    '1'
)

runTest(
    "Verify server-side bodies are binary",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_body_binary: true}, body: '{"a":5}'}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '123,34,97,34,58,53,125'
)

runTest(
    "Verify server-side bodies have body_text",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_body_text: true}, body: '{"a":5}'}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '{"a":5}'
)

runTest(
    "Verify server-side patches are binary",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_patch_binary: true, 'content-range': 'text [0:0]'}, body: '{"a":5}'}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '123,34,97,34,58,53,125\n'
)

runTest(
    "Verify server-side patches have content_text",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_patch_content_text: true, 'content-range': 'text [0:0]'}, body: '{"a":5}'}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '{"a":5}\n'
)

runTest(
    "Verify server-side 'everything' patches are binary",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_everything_patch_binary: true}, body: '{"a":5}'}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '123,34,97,34,58,53,125'
)

runTest(
    "Verify server-side 'everything' patches have content_text",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {method: 'PUT', headers: {check_everything_patch_content_text: true}, body: '{"a":5}'}).then(
                async res => resolve(res.text())).catch(reject)
        })
    },
    '{"a":5}'
)

runTest(
    "Handle client-side undefined body_text without exceptions",
    async () => {
        return '' + await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, headers: {skip_first: true}}).then(
                res => res.subscribe(
                    (update) => {
                        try {
                            resolve(update.body_text)
                        } catch (e) {
                            reject(e)
                        }
                    },
                    reject
                )).catch(reject)
        })
    },
    'undefined'
)

addSectionHeader("Misc")

runTest(
    "Verify that fetch params are not mutated",
    async () => {
        let x = {
            method: 'PUT',
            patches: [{
                unit: 'text', range: '[0:0]', content: 'hello'
            }]
        }
        let y = await (await fetch("/check_parents", x)).json()
        return x.patches[0].content
    },
    'hello'
)

runTest(
    "Verify content-type with charset=utf-8 is handled correctly",
    async () => {
        let updates = []
        await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true, headers: {charset: true}}).then(
                res => res.subscribe(
                    (update) => {
                        if (update.body != null) update.body = update.body_text
                        if (update.patches) for (let p of update.patches) p.content = p.content_text
                        updates.push(JSON.stringify(update))
                        if (updates.length === 5) resolve()
                    },
                    reject
                )).catch(reject)
        })
        return updates.join('\n')
    },
    '{"version":["test"],"parents":["oldie"],"body":"{\\\"this\\\":\\\"stuff\\\"}","status":"200"}\n' +
    '{"version":["test1"],"parents":["oldie","goodie"],"patches":[{"unit":"json","range":"[1]","content":"1"}],"status":"115","extra_headers":{"hash":"42"}}\n' +
    '{"version":["test2"],"patches":[{"unit":"json","range":"[2]","content":"2"}],"status":"200"}\n' +
    '{"version":["test3"],"patches":[{"unit":"json","range":"[3]","content":"3","extra_headers":{"hash":"43"}},{"unit":"json","range":"[4]","content":"4"}],"status":"200"}\n' +
    '{"version":["another!"],"body":"\\\"!\\\"","status":"200"}'
)

runTest(
    "Verify that parents option results in parents header",
    async () => {
        let x = { parents: ["test-0", "test-1"] }
        let y = await (await fetch("/check_parents", x)).json()
        return y.parents
    },
    '"test-0", "test-1"'
)

runTest(
    "Verify that parents option can be a function",
    async () => {
        let x = { parents: ["test-0", "test-1"] }
        let y = await (await fetch("/check_parents", { parents: () => x.parents })).json()
        return y.parents
    },
    '"test-0", "test-1"'
)

runTest(
    "Verify that parents option can be an async function",
    async () => {
        let x = { parents: ["test-0", "test-1"] }
        let y = await (await fetch("/check_parents", { parents: async () => x.parents })).json()
        return y.parents
    },
    '"test-0", "test-1"'
)


runTest(
    "onFetch test 1",
    async () => {
        let x = await new Promise(async (done, fail) => {
            await fetch('/json', {
                parents: () => ['test'],
                onFetch: (...args) => done(args)
            })
        })
        x[1].headers = Object.fromEntries([...x[1].headers])
        return JSON.stringify(x)
    },
    '["/json",{"headers":{"parents":"\\"test\\""},"cache":"no-cache","signal":{}}]'
)

runTest(
    "onBytes test 1",
    async () => {
        return await new Promise(async (done, fail) => {
            let s = ''
            let x = await fetch('/json', {
                subscribe: true,
                headers: {giveup: true},
                onBytes: (x) => {
                    s += new TextDecoder('utf-8').decode(x)
                }
            })
            x.subscribe(_ => done(s))
        })
    },
    "HTTP 200 OK\r\nVersion: \"test\"\r\nParents: \"oldie\"\r\nContent-Length: 16\r\n\r\n{\"this\":\"stuff\"}\r\n\r\n"
)

runTest(
    "parents-function test 1",
    async () => {
        let has_parents = null
        let x = { parents: null }
        let res = await (await fetch("/check_parents", { parents: () => x.parents, onFetch: (url, params) => {
            has_parents = JSON.stringify(params.headers.has('parents'))
        } })).json()
        return JSON.stringify({has_parents, res})
    },
    '{"has_parents":"false","res":{}}'
)

addSectionHeader("Heartbeat Tests")

runTest(
    "Verify heartbeat reception",
    async () => {
        let a = new AbortController()
        let x = await new Promise((resolve, reject) => {
            let st = Date.now()
            fetch('/json', {subscribe: true, heartbeats: 0.5, signal: a.signal, onBytes: () => {
                if (Date.now() - st > 500) resolve('got beat!')
            }}).then(res => res.subscribe(() => {}, reject)).catch(reject)
        })
        a.abort()
        return x
    },
    'got beat!'
)

runTest(
    "Verify absence of unwanted heartbeats",
    async () => {
        let a = new AbortController()
        let x = await new Promise((resolve, reject) => {
            let st = Date.now()
            setTimeout(() => resolve('did not get!'), 1000)
            fetch('/json', {subscribe: true, signal: a.signal, onBytes: () => {
                if (Date.now() - st > 500) resolve('got beat!')
            }}).then(res => res.subscribe(() => {}, reject)).catch(reject)
        })
        a.abort()
        return x
    },
    'did not get!'
)

runTest(
    "Restart connection on missed heartbeats",
    async () => {
        let res_count = 0
        let a = new AbortController()
        let x = await new Promise((resolve, reject) => {
            fetch('/noheartbeat', {heartbeats: 0.5, signal: a.signal, retry: {
                onRes: () => {
                    res_count++
                    if (res_count > 1) {
                        resolve('detected no heartbeat')
                    }
                }
            }}).then(res => res.subscribe(() => {}, reject)).catch(reject)
        })
        a.abort()
        return x
    },
    'detected no heartbeat'
)

runTest(
    "Maintain connection with regular heartbeats",
    async () => {
        let res_count = 0
        let a = new AbortController()
        let x = await new Promise((resolve, reject) => {
            setTimeout(() => resolve("didn't restart"), 1000);
            fetch('/json', {heartbeats: 0.5, subscribe: true, signal: a.signal, retry: {
                onRes: () => {
                    res_count++
                    if (res_count > 1) {
                        resolve('did restart')
                    }
                }
            }}).then(res => res.subscribe(() => {}, reject)).catch(reject)
        })
        a.abort()
        return x
    },
    "didn't restart"
)

addSectionHeader("Read Tests")

runTest(
    "Subscribe and receive multiple updates, using promise chaining",
    async () => {
        let updates = []
        await new Promise((resolve, reject) => {
            fetch('/json', {subscribe: true}).then(
                res => res.subscribe(
                    update => {
                        if (update.body != null) update.body = update.body_text
                        if (update.patches) for (let p of update.patches) p.content = p.content_text
                        updates.push(JSON.stringify(update))
                        if (updates.length === 5) resolve()
                    },
                    reject
                )).catch(reject)
        })
        return updates.join('\n')
    },
    '{"version":["test"],"parents":["oldie"],"body":"{\\\"this\\\":\\\"stuff\\\"}","status":"200"}\n' +
    '{"version":["test1"],"parents":["oldie","goodie"],"patches":[{"unit":"json","range":"[1]","content":"1"}],"status":"115","extra_headers":{"hash":"42"}}\n' +
    '{"version":["test2"],"patches":[{"unit":"json","range":"[2]","content":"2"}],"status":"200"}\n' +
    '{"version":["test3"],"patches":[{"unit":"json","range":"[3]","content":"3","extra_headers":{"hash":"43"}},{"unit":"json","range":"[4]","content":"4"}],"status":"200"}\n' +
    '{"version":["another!"],"body":"\\\"!\\\"","status":"200"}'
)

runTest(
    "Subscribe and receive multiple updates, using async/await",
    async () => {
        let updates = []
        await new Promise(async (resolve, reject) => {
            try {
                (await fetch('/json', {subscribe: true})).subscribe(
                    update => {
                        if (update.body != null) update.body = update.body_text
                        if (update.patches) for (let p of update.patches) p.content = p.content_text
                        updates.push(JSON.stringify(update))
                        if (updates.length === 5) resolve()
                    },
                    reject
                )
            } catch (e) {
                reject(e)
            }
        })
        return updates.join('\n')
    },
    '{"version":["test"],"parents":["oldie"],"body":"{\\\"this\\\":\\\"stuff\\\"}","status":"200"}\n' +
    '{"version":["test1"],"parents":["oldie","goodie"],"patches":[{"unit":"json","range":"[1]","content":"1"}],"status":"115","extra_headers":{"hash":"42"}}\n' +
    '{"version":["test2"],"patches":[{"unit":"json","range":"[2]","content":"2"}],"status":"200"}\n' +
    '{"version":["test3"],"patches":[{"unit":"json","range":"[3]","content":"3","extra_headers":{"hash":"43"}},{"unit":"json","range":"[4]","content":"4"}],"status":"200"}\n' +
    '{"version":["another!"],"body":"\\\"!\\\"","status":"200"}'
)

runTest(
    "Subscribe and receive multiple updates, using 'for await'",
    async () => {
        let updates = []
        for await (var update of (await fetch('/json', {subscribe: true})).subscription) {
            if (update.body != null) update.body = update.body_text
            if (update.patches) for (let p of update.patches) p.content = p.content_text
            updates.push(JSON.stringify(update))
            if (updates.length === 5) break
        }
        return updates.join('\n')
    },
    '{"version":["test"],"parents":["oldie"],"body":"{\\\"this\\\":\\\"stuff\\\"}","status":"200"}\n' +
    '{"version":["test1"],"parents":["oldie","goodie"],"patches":[{"unit":"json","range":"[1]","content":"1"}],"status":"115","extra_headers":{"hash":"42"}}\n' +
    '{"version":["test2"],"patches":[{"unit":"json","range":"[2]","content":"2"}],"status":"200"}\n' +
    '{"version":["test3"],"patches":[{"unit":"json","range":"[3]","content":"3","extra_headers":{"hash":"43"}},{"unit":"json","range":"[4]","content":"4"}],"status":"200"}\n' +
    '{"version":["another!"],"body":"\\\"!\\\"","status":"200"}'
)

addSectionHeader("Write Tests")

runTest(
    "PUT with single patch, not in array",
    async () => {
        let res = await fetch('/json', {
            version: ['test1'],
            patches: {unit: 'json', range: '[0]', content: '"test1"'},
            method: 'PUT'
        })
        return `returned ${res.status}`
    },
    "returned 200"
)

runTest(
    "PUT with single patch, in array",
    async () => {
        let res = await fetch('/json', {
            version: ['test2'],
            patches: [{unit: 'json', range: '[0]', content: '"test2"'}],
            method: 'PUT'
        })
        return `returned ${res.status}`
    },
    "returned 200"
)

runTest(
    "PUT with multiples patches",
    async () => {
        let res = await fetch('/json', {
            version: ['test3'],
            patches: [
                {unit: 'jsonpath', range: '[0]', content: '"test3"'},
                {unit: 'jsonpath', range: '[1]', content: '"test3"'},
                {unit: 'jsonpath', range: '[2]', content: '"test3"'}
            ],
            method: 'PUT'
        })
        return `returned ${res.status}`
    },
    "returned 200"
)

runTest(
    "PUT with empty patches array",
    async () => {
        let res = await fetch('/json', {
            version: ['test4'],
            patches: [],
            method: 'PUT'
        })
        return `returned ${res.status}`
    },
    "returned 200"
)

addSectionHeader('Testing braid wrapper for node http(s).get')

runTest(
    "Subscribe and receive multiple updates",
    async () => {
        const codeToEval = `
            let updates = []
            ;(new Promise((resolve, reject) => {
                https.get(
                    'https://localhost:' + port + '/json',
                    {subscribe: true, rejectUnauthorized: false},
                    (res) => {
                        res.on('update', (update) => {
                            if (update.body != null) update.body = update.body_text
                            if (update.patches) for (let p of update.patches) p.content = p.content_text
                            updates.push(update)
                            if (updates.length === 5) resolve()
                        })
                    }
                )
            })).then(() => {
                res.setHeader('Content-Type', 'application/json');
                res.end(JSON.stringify(updates));
            })
        `;

        const response = await fetch('/eval', {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: codeToEval
        });

        if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);

        const result = await response.json();
        
        return result.map(JSON.stringify).join('\n')
    },
    '{"version":["test"],"parents":["oldie"],"body":"{\\\"this\\\":\\\"stuff\\\"}","status":"200"}\n' +
    '{"version":["test1"],"parents":["oldie","goodie"],"patches":[{"unit":"json","range":"[1]","content":"1"}],"status":"115","extra_headers":{"hash":"42"}}\n' +
    '{"version":["test2"],"patches":[{"unit":"json","range":"[2]","content":"2"}],"status":"200"}\n' +
    '{"version":["test3"],"patches":[{"unit":"json","range":"[3]","content":"3","extra_headers":{"hash":"43"}},{"unit":"json","range":"[4]","content":"4"}],"status":"200"}\n' +
    '{"version":["another!"],"body":"\\\"!\\\"","status":"200"}'
);

runTest(
    "PUT with single patch, not in array",
    async () => {
        const codeToEval = `
            let p = new Promise((resolve, reject) => {
                https.get(
                    'https://localhost:' + port + '/json',
                    {
                        version: ['test1'],
                        patches: {unit: 'json', range: '[0]', content: '"test1"'},
                        method: 'PUT',
                        rejectUnauthorized: false
                    },
                    (res) => {
                        resolve('returned ' + res.statusCode)
                    }
                )            
            })
            p.then(x => {
                res.setHeader('Content-Type', 'application/json');
                res.end(JSON.stringify(x));
            })
        `;

        const response = await fetch('/eval', {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: codeToEval
        });

        if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);

        const result = await response.json();
        return result
    },
    'returned 200'
);

runTest(
    "PUT with single patch, in array",
    async () => {
        const codeToEval = `
            let p = new Promise((resolve, reject) => {
                https.get(
                    'https://localhost:' + port + '/json',
                    {
                        version: ['test2'],
                        patches: [{unit: 'json', range: '[0]', content: '"test2"'}],
                        method: 'PUT',
                        rejectUnauthorized: false
                    },
                    (res) => {
                        resolve('returned ' + res.statusCode)
                    }
                )            
            })
            p.then(x => {
                res.setHeader('Content-Type', 'application/json');
                res.end(JSON.stringify(x));
            })
        `;

        const response = await fetch('/eval', {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: codeToEval
        });

        if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);

        const result = await response.json();
        return result
    },
    'returned 200'
);

runTest(
    "PUT with multiples patches",
    async () => {
        const codeToEval = `
            let p = new Promise((resolve, reject) => {
                https.get(
                    'https://localhost:' + port + '/json',
                    {
                        version: ['test3'],
                        patches: [
                            {unit: 'jsonpath', range: '[0]', content: '"test3"'},
                            {unit: 'jsonpath', range: '[1]', content: '"test3"'},
                            {unit: 'jsonpath', range: '[2]', content: '"test3"'}
                        ],
                        method: 'PUT',
                        rejectUnauthorized: false
                    },
                    (res) => {
                        resolve('returned ' + res.statusCode)
                    }
                )            
            })
            p.then(x => {
                res.setHeader('Content-Type', 'application/json');
                res.end(JSON.stringify(x));
            })
        `;

        const response = await fetch('/eval', {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: codeToEval
        });

        if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);

        const result = await response.json();
        return result
    },
    'returned 200'
);

runTest(
    "PUT with empty patches array",
    async () => {
        const codeToEval = `
            let p = new Promise((resolve, reject) => {
                https.get(
                    'https://localhost:' + port + '/json',
                    {
                        version: ['test4'],
                        patches: [],
                        method: 'PUT',
                        rejectUnauthorized: false
                    },
                    (res) => {
                        resolve('returned ' + res.statusCode)
                    }
                )            
            })
            p.then(x => {
                res.setHeader('Content-Type', 'application/json');
                res.end(JSON.stringify(x));
            })
        `;

        const response = await fetch('/eval', {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: codeToEval
        });

        if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);

        const result = await response.json();
        return result
    },
    'returned 200'
);

addSectionHeader("Retry Tests")

runTest(
    "Verify that unparsable headers do not result in retrying connection.",
    async () => {
        let a = new AbortController()
        let count = 0
        return await new Promise(async (done, fail) => {
            let res = await fetch("/parse_error", { retry: {
                onRes: () => {
                    count++
                    if (count === 2) fail('retried')
                }
            }, subscribe: true, signal: a.signal })
            res.subscribe((u) => {}, done)
        })
    },
    'Parse error in headers: ""hello: true\\r\\nhello\\r\\nContent-Length: 2\\r\\n\\r\\n""'
)

runTest(
    "Should not retry on HTTP 400",
    async () => {
        try {
            await fetch("/400", { retry: true })
            throw new Error("Should have thrown an error")
        } catch (e) {
            return e.message
        }
    },
    "giving up because of http status: 400"
)

runTest(
    "Should not retry on HTTP 401 (access denied)",
    async () => {
        try {
            await fetch("/401", { retry: true })
            throw new Error("Should have thrown an error")
        } catch (e) {
            return e.message
        }
    },
    "giving up because of http status: 401 (access denied)"
)

runTest(
    "Should not try at all if abort controller already aborted",
    async () => {
        let a = new AbortController()
        a.abort()
        try {
            await fetch("/keep_open", { retry: true, signal: a.signal })
            throw new Error("Should have been aborted")
        } catch (e) {
            return e.message
        }
    },
    "already aborted"
)

runTest(
    "Should not retry if aborted",
    async () => {
        let a = new AbortController()
        setTimeout(() => a.abort(), 30)
        try {
            await fetch("/keep_open", { retry: true, signal: a.signal })
            throw new Error("Should have been aborted")
        } catch (e) {
            return e.name
        }
    },
    "AbortError"
)

runTest(
    "Should not retry if aborted, when subscribed",
    async () => {
        let good = false
        let a = new AbortController()
        try {
            let res = await fetch("/json", {
                signal: a.signal,
                retry: true,
                subscribe: true,
            })
            await new Promise((done, fail) => {
                setTimeout(() => a.abort(), 30)
                setTimeout(() => fail(new Error("abort failed 1")), 60)
                res.subscribe((update) => {
                    if (update.body != null) update.body = update.body_text
                    if (JSON.stringify(update) === JSON.stringify(test_update)) good = true
                }, fail)
            })
        } catch (e) {
            return e.name === "AbortError" && good ? "passed" : "failed"
        }
    },
    "passed"
)

runTest(
    "Verify that retry option works with subscribe",
    async () => {
        let a = new AbortController()
        let x = await new Promise(async (done, fail) => {
            try {
                var res = await braid_fetch("/json", {
                    retry: true,
                    signal: a.signal,
                    subscribe: true,
                })
            } catch (e) {
                fail(e)
            }
            res.subscribe(done, fail)
        })
        a.abort()
        if (x.body != null) x.body = x.body_text
        return JSON.stringify(x)
    },
    JSON.stringify(test_update)
)

var {status, ...test_update_without_status} = test_update
runTest(
    "Should retry on HTTP 408",
    async () => {
        let x = await (await fetch("/retry", { retry: true })).json()
        return JSON.stringify(x)
    },
    JSON.stringify(test_update_without_status)
)

runTest(
    "Verify that onRes is called on first connection",
    async () => {
        try {
            await new Promise((done, fail) => {
                fetch("/", { retry: { onRes: done } })
                setTimeout(() => fail(new Error("onRes was NOT called")), 100)
            })
            return "onRes was called"
        } catch (e) {
            return e.message
        }
    },
    "onRes was called"
)

runTest(
    "Verify that onRes is called on reconnections",
    async () => {
        let onRes_count = 0
        let update_count = 0
        try {
            await new Promise(async (done, fail) => {
                let a = new AbortController()
                let res = await fetch("/json", {
                    retry: { onRes: () => onRes_count++ },
                    subscribe: true,
                    headers: { giveup: true },
                    signal: a.signal,
                })
                res.subscribe(
                    (update) => {
                        if (update.body != null) update.body = update.body_text
                        if (JSON.stringify(update) === JSON.stringify(test_update)) update_count++
                        if (update_count > 1) done()
                    },
                    (e) => fail(new Error("fetch error: " + e))
                )
                setTimeout(() => {
                    a.abort()
                    fail(new Error("timed out: " + JSON.stringify({ onRes_count, update_count })))
                }, 200)
            })
            return `onRes_count=${onRes_count}, update_count=${update_count}`
        } catch (e) {
            return e.message
        }
    },
    "onRes_count=2, update_count=2"
)

runTest(
    "Verify that retry works with for-await style subscription",
    async () => {
        let updates = []
        let a = new AbortController()
        for await (var update of (await fetch('/json', {retry: true, signal: a.signal, subscribe: true, headers: {giveup: true}})).subscription) {
            if (update.body != null) update.body = update.body_text
            updates.push(JSON.stringify(update))

            if (updates.length === 3) break
        }
        a.abort()
        return updates.join('\n')
    },
    '{"version":["test"],"parents":["oldie"],"body":"{\\\"this\\\":\\\"stuff\\\"}","status":"200"}\n' +
    '{"version":["test"],"parents":["oldie"],"body":"{\\\"this\\\":\\\"stuff\\\"}","status":"200"}\n' +
    '{"version":["test"],"parents":["oldie"],"body":"{\\\"this\\\":\\\"stuff\\\"}","status":"200"}'
)

runTest(
    "Should stop retrying in a subscription if reconnection attempt returns HTTP 500",
    async () => {
        let giveup_completely = Math.random().toString(36).slice(2)
        let updates = []
        return await new Promise(async (done, fail) => {
            let res = await fetch('/json', {retry: true, subscribe: true, headers: {giveup_completely}})
            res.subscribe((update) => {
                if (update.body != null) update.body = update.body_text
                updates.push(JSON.stringify(update))
            }, (e) => {
                done('' + updates + ' -- ' + e)
            })
        })
    },
    '{"version":["test"],"parents":["oldie"],"body":"{\\"this\\":\\"stuff\\"}","status":"200"} -- Error: giving up because of http status: 500'
)

runTest(
    "Should throw an exception in for-await style when subscription encounters HTTP 500",
    async () => {
        let giveup_completely = Math.random().toString(36).slice(2)
        let updates = []
        try {
            for await (var update of (await fetch('/json', {retry: true, subscribe: true, headers: {giveup_completely}})).subscription) {
                if (update.body != null) update.body = update.body_text
                updates.push(JSON.stringify(update))
            }
        } catch (e) {
            return '' + updates + ' -- ' + e
        }
    },
    '{"version":["test"],"parents":["oldie"],"body":"{\\"this\\":\\"stuff\\"}","status":"200"} -- Error: giving up because of http status: 500'
)

addSectionHeader('Binary Tests')

runTest(
    "Verify basic binary GET",
    async () => {
        let x = await fetch('/binary')
        x = await x.arrayBuffer()
        x = new Uint8Array(x)
        x = [...x]
        return x.join(', ')
    },
    new Array(256).fill(0).map((x, i) => i).join(', ')
)

runTest(
    "Verify binary data in subscription update",
    async () => {
        let a = new AbortController()
        let x = await new Promise(async (done, fail) => {
            let x = await fetch('/binary', {subscribe: true, signal: a.signal})
            x.subscribe(done, fail)
        })
        a.abort()
        return '' + x.body
    },
    '' + new Array(256).fill(0).map((x, i) => i)
)

</script>
